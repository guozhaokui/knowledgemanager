<!DOCTYPE html>
<html>
  <head>
    <title>Hello World!</title>
  </head>
  <body>
    <div style="width:100%;height:100%"></div>
    We are using io.js <script>document.write(process.version)</script>
    and Electron <script>document.write(process.versions['electron'])</script>.
    curexepath=<script>document.write(window.xxo)</script>.
	<canvas id="myCanvas" width="400" height="200" style="border:1px solid #d3d3d3;">Your browser does not support the HTML5 canvas tag.</canvas>
	<script>
		var sentchk = require('../sample/reader1.js').check;
		var fs = require('fs');
		var path = require('path');
		var b1 = fs.readFileSync(path.resolve(path.dirname(__filename),'../sample/word5.txt'),'utf8');
		var ba = b1.split('\n');
		var bk = new Array(ba.length);
		var ii=0;
		ba.forEach(function(w){
			w=w.substr(0,5);
			bk[ii++]=[w,sentchk(w)];
		});
		bk.sort(function(a,b){return b[1]-a[1];});
		bk.forEach(function(v){
		console.log(v[0]+','+v[1]);
		});
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");

		ctx.fillStyle="black";
		ctx.strokeStyle="black";

		ctx.strokeRect(0,0,100,100);
		ctx.strokeStyle="green";
		//ctx.strokeRect(0,0,800,480);

		var req1,req2;
		function step(tm){
			console.log('tm='+tm);
			//if(tm>200)
			//	cancelAnimationFrame();
			if(tm>2000){
				req2=requestAnimationFrame(step2);
				console.log('req2='+req2);
			}else{
				req1 = requestAnimationFrame(step);
				console.log('req1='+req1);
			}
			if(tm>3000){
			}
			//req2 = requestAnimationFrame(step);
		}
		function step2(tm){
			console.log('xxx tm='+tm);
			req2 = requestAnimationFrame(step2);
			if(tm>3000){
				cancelAnimationFrame(req2);
				requestAnimationFrame(step);
			}
		}
		req1=requestAnimationFrame(step);
		cancelAnimationFrame(req1);
		console.log('req='+req1+','+req2);
		/*
			每次 requestAnimationFrame 都会创建一个新的，id总是一直增加，即使调用的函数相同。
			时间总是从第一个开始。
			时间永远不会回到开始，即使调用 cancelAnimationFrame 也不行
		*/
	</script>	
  </body>
</html>
